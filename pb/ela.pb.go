// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ela.proto

package pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type LifecycleStatus int32

const (
	LifecycleStatus_UNKNOWN  LifecycleStatus = 0
	LifecycleStatus_READY    LifecycleStatus = 1
	LifecycleStatus_STARTING LifecycleStatus = 2
	LifecycleStatus_RUNNING  LifecycleStatus = 3
	LifecycleStatus_STOPPING LifecycleStatus = 4
	LifecycleStatus_STOPPED  LifecycleStatus = 5
	LifecycleStatus_ERROR    LifecycleStatus = 6
)

var LifecycleStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "READY",
	2: "STARTING",
	3: "RUNNING",
	4: "STOPPING",
	5: "STOPPED",
	6: "ERROR",
}

var LifecycleStatus_value = map[string]int32{
	"UNKNOWN":  0,
	"READY":    1,
	"STARTING": 2,
	"RUNNING":  3,
	"STOPPING": 4,
	"STOPPED":  5,
	"ERROR":    6,
}

func (x LifecycleStatus) String() string {
	return proto.EnumName(LifecycleStatus_name, int32(x))
}

func (LifecycleStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{0}
}

type TrafficTarget_TargetAction int32

const (
	TrafficTarget_ACCEPT TrafficTarget_TargetAction = 0
	TrafficTarget_REJECT TrafficTarget_TargetAction = 1
	TrafficTarget_DROP   TrafficTarget_TargetAction = 2
)

var TrafficTarget_TargetAction_name = map[int32]string{
	0: "ACCEPT",
	1: "REJECT",
	2: "DROP",
}

var TrafficTarget_TargetAction_value = map[string]int32{
	"ACCEPT": 0,
	"REJECT": 1,
	"DROP":   2,
}

func (x TrafficTarget_TargetAction) String() string {
	return proto.EnumName(TrafficTarget_TargetAction_name, int32(x))
}

func (TrafficTarget_TargetAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{10, 0}
}

type NetworkInterface_InterfaceDriver int32

const (
	NetworkInterface_KERNEL    NetworkInterface_InterfaceDriver = 0
	NetworkInterface_USERSPACE NetworkInterface_InterfaceDriver = 1
)

var NetworkInterface_InterfaceDriver_name = map[int32]string{
	0: "KERNEL",
	1: "USERSPACE",
}

var NetworkInterface_InterfaceDriver_value = map[string]int32{
	"KERNEL":    0,
	"USERSPACE": 1,
}

func (x NetworkInterface_InterfaceDriver) String() string {
	return proto.EnumName(NetworkInterface_InterfaceDriver_name, int32(x))
}

func (NetworkInterface_InterfaceDriver) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{13, 0}
}

type NetworkInterface_InterfaceType int32

const (
	NetworkInterface_NONE          NetworkInterface_InterfaceType = 0
	NetworkInterface_UPSTREAM      NetworkInterface_InterfaceType = 1
	NetworkInterface_DOWNSTREAM    NetworkInterface_InterfaceType = 2
	NetworkInterface_BIDIRECTIONAL NetworkInterface_InterfaceType = 3
	NetworkInterface_BREAKOUT      NetworkInterface_InterfaceType = 4
)

var NetworkInterface_InterfaceType_name = map[int32]string{
	0: "NONE",
	1: "UPSTREAM",
	2: "DOWNSTREAM",
	3: "BIDIRECTIONAL",
	4: "BREAKOUT",
}

var NetworkInterface_InterfaceType_value = map[string]int32{
	"NONE":          0,
	"UPSTREAM":      1,
	"DOWNSTREAM":    2,
	"BIDIRECTIONAL": 3,
	"BREAKOUT":      4,
}

func (x NetworkInterface_InterfaceType) String() string {
	return proto.EnumName(NetworkInterface_InterfaceType_name, int32(x))
}

func (NetworkInterface_InterfaceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{13, 1}
}

type NetworkSetting_Status int32

const (
	NetworkSetting_NONE   NetworkSetting_Status = 0
	NetworkSetting_STATIC NetworkSetting_Status = 1
	NetworkSetting_DHCPv4 NetworkSetting_Status = 2
	NetworkSetting_DHCPv6 NetworkSetting_Status = 3
	NetworkSetting_SLAAC  NetworkSetting_Status = 4
)

var NetworkSetting_Status_name = map[int32]string{
	0: "NONE",
	1: "STATIC",
	2: "DHCPv4",
	3: "DHCPv6",
	4: "SLAAC",
}

var NetworkSetting_Status_value = map[string]int32{
	"NONE":   0,
	"STATIC": 1,
	"DHCPv4": 2,
	"DHCPv6": 3,
	"SLAAC":  4,
}

func (x NetworkSetting_Status) String() string {
	return proto.EnumName(NetworkSetting_Status_name, int32(x))
}

func (NetworkSetting_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{17, 0}
}

type LifecycleCommand_Command int32

const (
	LifecycleCommand_START   LifecycleCommand_Command = 0
	LifecycleCommand_STOP    LifecycleCommand_Command = 1
	LifecycleCommand_RESTART LifecycleCommand_Command = 2
)

var LifecycleCommand_Command_name = map[int32]string{
	0: "START",
	1: "STOP",
	2: "RESTART",
}

var LifecycleCommand_Command_value = map[string]int32{
	"START":   0,
	"STOP":    1,
	"RESTART": 2,
}

func (x LifecycleCommand_Command) String() string {
	return proto.EnumName(LifecycleCommand_Command_name, int32(x))
}

func (LifecycleCommand_Command) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{18, 0}
}

// Application message - contains information about the application
// we're about to deploy (or one already deployed).
// image string is used to build the url to download the image from over http
// url is the following: http://${controller_name}/app_images/${image}
// - so the last part is our image string - which is basically a file name
// with a possible additional path prefixed
type Application struct {
	Id                   string          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Vendor               string          `protobuf:"bytes,3,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Description          string          `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Image                string          `protobuf:"bytes,5,opt,name=image,proto3" json:"image,omitempty"`
	Cores                int32           `protobuf:"varint,6,opt,name=cores,proto3" json:"cores,omitempty"`
	Memory               int32           `protobuf:"varint,7,opt,name=memory,proto3" json:"memory,omitempty"`
	Status               LifecycleStatus `protobuf:"varint,8,opt,name=status,proto3,enum=openness.ela.LifecycleStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Application) Reset()         { *m = Application{} }
func (m *Application) String() string { return proto.CompactTextString(m) }
func (*Application) ProtoMessage()    {}
func (*Application) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{0}
}

func (m *Application) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Application.Unmarshal(m, b)
}
func (m *Application) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Application.Marshal(b, m, deterministic)
}
func (m *Application) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Application.Merge(m, src)
}
func (m *Application) XXX_Size() int {
	return xxx_messageInfo_Application.Size(m)
}
func (m *Application) XXX_DiscardUnknown() {
	xxx_messageInfo_Application.DiscardUnknown(m)
}

var xxx_messageInfo_Application proto.InternalMessageInfo

func (m *Application) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Application) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Application) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Application) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Application) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Application) GetCores() int32 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *Application) GetMemory() int32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Application) GetStatus() LifecycleStatus {
	if m != nil {
		return m.Status
	}
	return LifecycleStatus_UNKNOWN
}

type Applications struct {
	Applications         []*Application `protobuf:"bytes,1,rep,name=applications,proto3" json:"applications,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Applications) Reset()         { *m = Applications{} }
func (m *Applications) String() string { return proto.CompactTextString(m) }
func (*Applications) ProtoMessage()    {}
func (*Applications) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{1}
}

func (m *Applications) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Applications.Unmarshal(m, b)
}
func (m *Applications) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Applications.Marshal(b, m, deterministic)
}
func (m *Applications) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Applications.Merge(m, src)
}
func (m *Applications) XXX_Size() int {
	return xxx_messageInfo_Applications.Size(m)
}
func (m *Applications) XXX_DiscardUnknown() {
	xxx_messageInfo_Applications.DiscardUnknown(m)
}

var xxx_messageInfo_Applications proto.InternalMessageInfo

func (m *Applications) GetApplications() []*Application {
	if m != nil {
		return m.Applications
	}
	return nil
}

type VNF struct {
	Id                   string          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string          `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Vendor               string          `protobuf:"bytes,3,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Description          string          `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Image                string          `protobuf:"bytes,5,opt,name=image,proto3" json:"image,omitempty"`
	Cores                int32           `protobuf:"varint,6,opt,name=cores,proto3" json:"cores,omitempty"`
	Memory               int32           `protobuf:"varint,7,opt,name=memory,proto3" json:"memory,omitempty"`
	Status               LifecycleStatus `protobuf:"varint,8,opt,name=status,proto3,enum=openness.ela.LifecycleStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *VNF) Reset()         { *m = VNF{} }
func (m *VNF) String() string { return proto.CompactTextString(m) }
func (*VNF) ProtoMessage()    {}
func (*VNF) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{2}
}

func (m *VNF) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VNF.Unmarshal(m, b)
}
func (m *VNF) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VNF.Marshal(b, m, deterministic)
}
func (m *VNF) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VNF.Merge(m, src)
}
func (m *VNF) XXX_Size() int {
	return xxx_messageInfo_VNF.Size(m)
}
func (m *VNF) XXX_DiscardUnknown() {
	xxx_messageInfo_VNF.DiscardUnknown(m)
}

var xxx_messageInfo_VNF proto.InternalMessageInfo

func (m *VNF) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *VNF) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VNF) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *VNF) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *VNF) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *VNF) GetCores() int32 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *VNF) GetMemory() int32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *VNF) GetStatus() LifecycleStatus {
	if m != nil {
		return m.Status
	}
	return LifecycleStatus_UNKNOWN
}

type VNFs struct {
	Vnfs                 []*VNF   `protobuf:"bytes,1,rep,name=vnfs,proto3" json:"vnfs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VNFs) Reset()         { *m = VNFs{} }
func (m *VNFs) String() string { return proto.CompactTextString(m) }
func (*VNFs) ProtoMessage()    {}
func (*VNFs) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{3}
}

func (m *VNFs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VNFs.Unmarshal(m, b)
}
func (m *VNFs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VNFs.Marshal(b, m, deterministic)
}
func (m *VNFs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VNFs.Merge(m, src)
}
func (m *VNFs) XXX_Size() int {
	return xxx_messageInfo_VNFs.Size(m)
}
func (m *VNFs) XXX_DiscardUnknown() {
	xxx_messageInfo_VNFs.DiscardUnknown(m)
}

var xxx_messageInfo_VNFs proto.InternalMessageInfo

func (m *VNFs) GetVnfs() []*VNF {
	if m != nil {
		return m.Vnfs
	}
	return nil
}

// TrafficPolicy is a policy that defines a set of traffic rules for the
// identified component (i.e. an application, an interface, etc.)
//
// A policy engine applies these rules, using the context of the identified
// component in order to send traffic to a target. The policy engine acts as
// a man-in-the-middle. It may modify the packets in order to facilitate the
// traffic flow. Examples of a policy engine are DPDK, VPP or iptables
// applications.
type TrafficPolicy struct {
	Id                   string         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	TrafficRules         []*TrafficRule `protobuf:"bytes,2,rep,name=traffic_rules,json=trafficRules,proto3" json:"traffic_rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TrafficPolicy) Reset()         { *m = TrafficPolicy{} }
func (m *TrafficPolicy) String() string { return proto.CompactTextString(m) }
func (*TrafficPolicy) ProtoMessage()    {}
func (*TrafficPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{4}
}

func (m *TrafficPolicy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrafficPolicy.Unmarshal(m, b)
}
func (m *TrafficPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrafficPolicy.Marshal(b, m, deterministic)
}
func (m *TrafficPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficPolicy.Merge(m, src)
}
func (m *TrafficPolicy) XXX_Size() int {
	return xxx_messageInfo_TrafficPolicy.Size(m)
}
func (m *TrafficPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficPolicy proto.InternalMessageInfo

func (m *TrafficPolicy) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TrafficPolicy) GetTrafficRules() []*TrafficRule {
	if m != nil {
		return m.TrafficRules
	}
	return nil
}

// TrafficRule defines a single traffic rule. The traffic selectors are used in
// order to construct both a rule that must be matched as well as what action
// to take on the traffic if the rule is matched.
//
// Since this is generic, the receiver of this rule must validate if the
// information provided by the caller is sufficient enough to construct a
// policy of a particular type.
//
// A single rule only allows one of each traffic selector to be specified.
// However, if a system supports advanced networking rules, a traffic rule can
// specify a subnet mask or a range in order to create a more dynamic rule.
//
// For example, a rule with a source selector of 10.20.30.0/24 could match all
// source traffic in that subnet block.
type TrafficRule struct {
	Description          string           `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Priority             uint32           `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"`
	Source               *TrafficSelector `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	Destination          *TrafficSelector `protobuf:"bytes,4,opt,name=destination,proto3" json:"destination,omitempty"`
	Target               *TrafficTarget   `protobuf:"bytes,5,opt,name=target,proto3" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TrafficRule) Reset()         { *m = TrafficRule{} }
func (m *TrafficRule) String() string { return proto.CompactTextString(m) }
func (*TrafficRule) ProtoMessage()    {}
func (*TrafficRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{5}
}

func (m *TrafficRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrafficRule.Unmarshal(m, b)
}
func (m *TrafficRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrafficRule.Marshal(b, m, deterministic)
}
func (m *TrafficRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficRule.Merge(m, src)
}
func (m *TrafficRule) XXX_Size() int {
	return xxx_messageInfo_TrafficRule.Size(m)
}
func (m *TrafficRule) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficRule.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficRule proto.InternalMessageInfo

func (m *TrafficRule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TrafficRule) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *TrafficRule) GetSource() *TrafficSelector {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *TrafficRule) GetDestination() *TrafficSelector {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *TrafficRule) GetTarget() *TrafficTarget {
	if m != nil {
		return m.Target
	}
	return nil
}

// TrafficSelector defines the parameters for a traffic selector in a
// TrafficRule. If a filter is empty, the selector does not evaluate it. The
// receiver can select traffic by using the filters as it is examining a packet
// or payload. They must filter using the OSI stack from layer 7 to layer 1.
// For example, if a MAC and IP are provided, the selector must first evaluate
// the IP (layer 3) before the MAC (layer 2).
//
// If a TrafficSelector has only the MAC filter specified, the selector is
// created only for that filter. However, if the selector contains a GTP and IP
// filter, the selector is created on both and the traffic must match both
// filters.
type TrafficSelector struct {
	Description          string     `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Macs                 *MACFilter `protobuf:"bytes,2,opt,name=macs,proto3" json:"macs,omitempty"`
	Ip                   *IPFilter  `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip,omitempty"`
	Gtp                  *GTPFilter `protobuf:"bytes,4,opt,name=gtp,proto3" json:"gtp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TrafficSelector) Reset()         { *m = TrafficSelector{} }
func (m *TrafficSelector) String() string { return proto.CompactTextString(m) }
func (*TrafficSelector) ProtoMessage()    {}
func (*TrafficSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{6}
}

func (m *TrafficSelector) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrafficSelector.Unmarshal(m, b)
}
func (m *TrafficSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrafficSelector.Marshal(b, m, deterministic)
}
func (m *TrafficSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficSelector.Merge(m, src)
}
func (m *TrafficSelector) XXX_Size() int {
	return xxx_messageInfo_TrafficSelector.Size(m)
}
func (m *TrafficSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficSelector.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficSelector proto.InternalMessageInfo

func (m *TrafficSelector) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TrafficSelector) GetMacs() *MACFilter {
	if m != nil {
		return m.Macs
	}
	return nil
}

func (m *TrafficSelector) GetIp() *IPFilter {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *TrafficSelector) GetGtp() *GTPFilter {
	if m != nil {
		return m.Gtp
	}
	return nil
}

// MACFilter specifies properties related to MAC filters. Some implementations
// may not support multiple MAC addresses.
type MACFilter struct {
	MacAddresses         []string `protobuf:"bytes,1,rep,name=mac_addresses,json=macAddresses,proto3" json:"mac_addresses,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MACFilter) Reset()         { *m = MACFilter{} }
func (m *MACFilter) String() string { return proto.CompactTextString(m) }
func (*MACFilter) ProtoMessage()    {}
func (*MACFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{7}
}

func (m *MACFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MACFilter.Unmarshal(m, b)
}
func (m *MACFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MACFilter.Marshal(b, m, deterministic)
}
func (m *MACFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MACFilter.Merge(m, src)
}
func (m *MACFilter) XXX_Size() int {
	return xxx_messageInfo_MACFilter.Size(m)
}
func (m *MACFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_MACFilter.DiscardUnknown(m)
}

var xxx_messageInfo_MACFilter proto.InternalMessageInfo

func (m *MACFilter) GetMacAddresses() []string {
	if m != nil {
		return m.MacAddresses
	}
	return nil
}

// IPFilter specifies properties related to IP filters. Some implementations
// may not support multiple IP address (subnets) or have IPv6 support.
//
// If a caller wishes to define a single port, begin_port and end_port should
// be the same. For example, if the port is 3306, begin_port is 3306 and
// end_port is 3306. It is invalid to provide a begin_port that is greater than
// the end_port.
//
// Leaving the address and mask fields empty implies that all possible IP
// addresses are in the filter. Leaving these primitive datatypes empty
// defaults to the type's zero-value (as is the norm in protobuf). The
// following describes the behavior depending on how the fields are populated:
//  ___________________________________________________________________________
// |      Address      |      Mask      |               Result                |
// |   Zero-value ("") | Zero-value (0) |  All IPv4 (and IPv6, if supported)  |
// |    "0.0.0.0"      | Zero-value (0) |  All IPv4 only                      |
// |       "::"        | Zero-value (0) |  All IPv6 only (if supported)       |
// |    "1.2.3.4"      | Zero-value (0) |  Invalid                            |
// |   Zero-value ("") |       24       |  Invalid                            |
//  ___________________________________________________________________________
type IPFilter struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Mask                 uint32   `protobuf:"varint,2,opt,name=mask,proto3" json:"mask,omitempty"`
	BeginPort            uint32   `protobuf:"varint,3,opt,name=begin_port,json=beginPort,proto3" json:"begin_port,omitempty"`
	EndPort              uint32   `protobuf:"varint,4,opt,name=end_port,json=endPort,proto3" json:"end_port,omitempty"`
	Protocol             string   `protobuf:"bytes,5,opt,name=protocol,proto3" json:"protocol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPFilter) Reset()         { *m = IPFilter{} }
func (m *IPFilter) String() string { return proto.CompactTextString(m) }
func (*IPFilter) ProtoMessage()    {}
func (*IPFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{8}
}

func (m *IPFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPFilter.Unmarshal(m, b)
}
func (m *IPFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPFilter.Marshal(b, m, deterministic)
}
func (m *IPFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPFilter.Merge(m, src)
}
func (m *IPFilter) XXX_Size() int {
	return xxx_messageInfo_IPFilter.Size(m)
}
func (m *IPFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_IPFilter.DiscardUnknown(m)
}

var xxx_messageInfo_IPFilter proto.InternalMessageInfo

func (m *IPFilter) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *IPFilter) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

func (m *IPFilter) GetBeginPort() uint32 {
	if m != nil {
		return m.BeginPort
	}
	return 0
}

func (m *IPFilter) GetEndPort() uint32 {
	if m != nil {
		return m.EndPort
	}
	return 0
}

func (m *IPFilter) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

// GTPFilter specifies properties related to GTP filters. Some implementations
// may not support multiple addresses or multiple IMSIs.
type GTPFilter struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Mask                 uint32   `protobuf:"varint,2,opt,name=mask,proto3" json:"mask,omitempty"`
	Imsis                []string `protobuf:"bytes,3,rep,name=imsis,proto3" json:"imsis,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GTPFilter) Reset()         { *m = GTPFilter{} }
func (m *GTPFilter) String() string { return proto.CompactTextString(m) }
func (*GTPFilter) ProtoMessage()    {}
func (*GTPFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{9}
}

func (m *GTPFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GTPFilter.Unmarshal(m, b)
}
func (m *GTPFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GTPFilter.Marshal(b, m, deterministic)
}
func (m *GTPFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GTPFilter.Merge(m, src)
}
func (m *GTPFilter) XXX_Size() int {
	return xxx_messageInfo_GTPFilter.Size(m)
}
func (m *GTPFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_GTPFilter.DiscardUnknown(m)
}

var xxx_messageInfo_GTPFilter proto.InternalMessageInfo

func (m *GTPFilter) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GTPFilter) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

func (m *GTPFilter) GetImsis() []string {
	if m != nil {
		return m.Imsis
	}
	return nil
}

// TrafficTarget defines the parameters for a traffic target in a TrafficRule.
// The action indicates what target action to perform. If a modify field is
// empty, the target does not perform that type of modification.
//
// For example, if the target should modify the MAC address, then it should be
// provided in the message. The modifiers are currently only applicable if the
// interface is trying to modify the traffic, such as is the case with a
// breakout interface.
type TrafficTarget struct {
	Description          string                     `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Action               TrafficTarget_TargetAction `protobuf:"varint,2,opt,name=action,proto3,enum=openness.ela.TrafficTarget_TargetAction" json:"action,omitempty"`
	Mac                  *MACModifier               `protobuf:"bytes,3,opt,name=mac,proto3" json:"mac,omitempty"`
	Ip                   *IPModifier                `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TrafficTarget) Reset()         { *m = TrafficTarget{} }
func (m *TrafficTarget) String() string { return proto.CompactTextString(m) }
func (*TrafficTarget) ProtoMessage()    {}
func (*TrafficTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{10}
}

func (m *TrafficTarget) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrafficTarget.Unmarshal(m, b)
}
func (m *TrafficTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrafficTarget.Marshal(b, m, deterministic)
}
func (m *TrafficTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficTarget.Merge(m, src)
}
func (m *TrafficTarget) XXX_Size() int {
	return xxx_messageInfo_TrafficTarget.Size(m)
}
func (m *TrafficTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficTarget.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficTarget proto.InternalMessageInfo

func (m *TrafficTarget) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TrafficTarget) GetAction() TrafficTarget_TargetAction {
	if m != nil {
		return m.Action
	}
	return TrafficTarget_ACCEPT
}

func (m *TrafficTarget) GetMac() *MACModifier {
	if m != nil {
		return m.Mac
	}
	return nil
}

func (m *TrafficTarget) GetIp() *IPModifier {
	if m != nil {
		return m.Ip
	}
	return nil
}

// MACModifier defines the MAC properties that should be modified.
type MACModifier struct {
	MacAddress           string   `protobuf:"bytes,1,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MACModifier) Reset()         { *m = MACModifier{} }
func (m *MACModifier) String() string { return proto.CompactTextString(m) }
func (*MACModifier) ProtoMessage()    {}
func (*MACModifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{11}
}

func (m *MACModifier) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MACModifier.Unmarshal(m, b)
}
func (m *MACModifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MACModifier.Marshal(b, m, deterministic)
}
func (m *MACModifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MACModifier.Merge(m, src)
}
func (m *MACModifier) XXX_Size() int {
	return xxx_messageInfo_MACModifier.Size(m)
}
func (m *MACModifier) XXX_DiscardUnknown() {
	xxx_messageInfo_MACModifier.DiscardUnknown(m)
}

var xxx_messageInfo_MACModifier proto.InternalMessageInfo

func (m *MACModifier) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

// IPModifier defines the IP properties that should be modified
type IPModifier struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port                 uint32   `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPModifier) Reset()         { *m = IPModifier{} }
func (m *IPModifier) String() string { return proto.CompactTextString(m) }
func (*IPModifier) ProtoMessage()    {}
func (*IPModifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{12}
}

func (m *IPModifier) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPModifier.Unmarshal(m, b)
}
func (m *IPModifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPModifier.Marshal(b, m, deterministic)
}
func (m *IPModifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPModifier.Merge(m, src)
}
func (m *IPModifier) XXX_Size() int {
	return xxx_messageInfo_IPModifier.Size(m)
}
func (m *IPModifier) XXX_DiscardUnknown() {
	xxx_messageInfo_IPModifier.DiscardUnknown(m)
}

var xxx_messageInfo_IPModifier proto.InternalMessageInfo

func (m *IPModifier) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *IPModifier) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// NetworkInterface defines a network interface available on the host.
// Interfaces are typically kernel interfaces by default, and can be changed if
// the caller wishes to do so.
//
// The interface's type assists the policy engine in determining what types of
// traffic the interface can expect to be handling, and is mainly here for
// support of legacy implementations (which may require the field is updated in
// order to work properly).
//
// An interface can belong to multiple zones, which can be useful for when
// the amount of actual interfaces is limited.
type NetworkInterface struct {
	Id          string                           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Description string                           `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Driver      NetworkInterface_InterfaceDriver `protobuf:"varint,3,opt,name=driver,proto3,enum=openness.ela.NetworkInterface_InterfaceDriver" json:"driver,omitempty"`
	Type        NetworkInterface_InterfaceType   `protobuf:"varint,4,opt,name=type,proto3,enum=openness.ela.NetworkInterface_InterfaceType" json:"type,omitempty"`
	MacAddress  string                           `protobuf:"bytes,5,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	Vlan        uint32                           `protobuf:"varint,6,opt,name=vlan,proto3" json:"vlan,omitempty"`
	Zones       []string                         `protobuf:"bytes,7,rep,name=zones,proto3" json:"zones,omitempty"`
	// (LEGACY) The fallback interface for this interface. This only exists for
	// legacy dataplane implementations. In future implementations, a traffic
	// policy should be used to yield the same results. Using this is not
	// advisable as it belongs in the traffic policy and exposes a fallback
	// behavior that can be seen as insecure.
	FallbackInterface    string   `protobuf:"bytes,8,opt,name=fallback_interface,json=fallbackInterface,proto3" json:"fallback_interface,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkInterface) Reset()         { *m = NetworkInterface{} }
func (m *NetworkInterface) String() string { return proto.CompactTextString(m) }
func (*NetworkInterface) ProtoMessage()    {}
func (*NetworkInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{13}
}

func (m *NetworkInterface) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkInterface.Unmarshal(m, b)
}
func (m *NetworkInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkInterface.Marshal(b, m, deterministic)
}
func (m *NetworkInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterface.Merge(m, src)
}
func (m *NetworkInterface) XXX_Size() int {
	return xxx_messageInfo_NetworkInterface.Size(m)
}
func (m *NetworkInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterface.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterface proto.InternalMessageInfo

func (m *NetworkInterface) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NetworkInterface) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *NetworkInterface) GetDriver() NetworkInterface_InterfaceDriver {
	if m != nil {
		return m.Driver
	}
	return NetworkInterface_KERNEL
}

func (m *NetworkInterface) GetType() NetworkInterface_InterfaceType {
	if m != nil {
		return m.Type
	}
	return NetworkInterface_NONE
}

func (m *NetworkInterface) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *NetworkInterface) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *NetworkInterface) GetZones() []string {
	if m != nil {
		return m.Zones
	}
	return nil
}

func (m *NetworkInterface) GetFallbackInterface() string {
	if m != nil {
		return m.FallbackInterface
	}
	return ""
}

type NetworkInterfaces struct {
	NetworkInterfaces    []*NetworkInterface `protobuf:"bytes,1,rep,name=network_interfaces,json=networkInterfaces,proto3" json:"network_interfaces,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *NetworkInterfaces) Reset()         { *m = NetworkInterfaces{} }
func (m *NetworkInterfaces) String() string { return proto.CompactTextString(m) }
func (*NetworkInterfaces) ProtoMessage()    {}
func (*NetworkInterfaces) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{14}
}

func (m *NetworkInterfaces) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkInterfaces.Unmarshal(m, b)
}
func (m *NetworkInterfaces) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkInterfaces.Marshal(b, m, deterministic)
}
func (m *NetworkInterfaces) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterfaces.Merge(m, src)
}
func (m *NetworkInterfaces) XXX_Size() int {
	return xxx_messageInfo_NetworkInterfaces.Size(m)
}
func (m *NetworkInterfaces) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterfaces.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterfaces proto.InternalMessageInfo

func (m *NetworkInterfaces) GetNetworkInterfaces() []*NetworkInterface {
	if m != nil {
		return m.NetworkInterfaces
	}
	return nil
}

// NetworkZone defines a network zone. A zone is effectively a label that
// isolates network traffic within an appliance. It allows for further rules
// to be made surrounding the zone and interfaces that are assigned to it.
type NetworkZone struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkZone) Reset()         { *m = NetworkZone{} }
func (m *NetworkZone) String() string { return proto.CompactTextString(m) }
func (*NetworkZone) ProtoMessage()    {}
func (*NetworkZone) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{15}
}

func (m *NetworkZone) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkZone.Unmarshal(m, b)
}
func (m *NetworkZone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkZone.Marshal(b, m, deterministic)
}
func (m *NetworkZone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkZone.Merge(m, src)
}
func (m *NetworkZone) XXX_Size() int {
	return xxx_messageInfo_NetworkZone.Size(m)
}
func (m *NetworkZone) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkZone.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkZone proto.InternalMessageInfo

func (m *NetworkZone) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NetworkZone) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type NetworkZones struct {
	NetworkZones         []*NetworkZone `protobuf:"bytes,1,rep,name=network_zones,json=networkZones,proto3" json:"network_zones,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NetworkZones) Reset()         { *m = NetworkZones{} }
func (m *NetworkZones) String() string { return proto.CompactTextString(m) }
func (*NetworkZones) ProtoMessage()    {}
func (*NetworkZones) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{16}
}

func (m *NetworkZones) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkZones.Unmarshal(m, b)
}
func (m *NetworkZones) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkZones.Marshal(b, m, deterministic)
}
func (m *NetworkZones) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkZones.Merge(m, src)
}
func (m *NetworkZones) XXX_Size() int {
	return xxx_messageInfo_NetworkZones.Size(m)
}
func (m *NetworkZones) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkZones.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkZones proto.InternalMessageInfo

func (m *NetworkZones) GetNetworkZones() []*NetworkZone {
	if m != nil {
		return m.NetworkZones
	}
	return nil
}

// NetworkSetting defines a network setting. It can be included in an interface
// to configure it's IP properties.
type NetworkSetting struct {
	Status               NetworkSetting_Status `protobuf:"varint,1,opt,name=status,proto3,enum=openness.ela.NetworkSetting_Status" json:"status,omitempty"`
	Address              string                `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Mask                 uint32                `protobuf:"varint,3,opt,name=mask,proto3" json:"mask,omitempty"`
	Gateway              string                `protobuf:"bytes,4,opt,name=gateway,proto3" json:"gateway,omitempty"`
	Dns                  []string              `protobuf:"bytes,5,rep,name=dns,proto3" json:"dns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *NetworkSetting) Reset()         { *m = NetworkSetting{} }
func (m *NetworkSetting) String() string { return proto.CompactTextString(m) }
func (*NetworkSetting) ProtoMessage()    {}
func (*NetworkSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{17}
}

func (m *NetworkSetting) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkSetting.Unmarshal(m, b)
}
func (m *NetworkSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkSetting.Marshal(b, m, deterministic)
}
func (m *NetworkSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkSetting.Merge(m, src)
}
func (m *NetworkSetting) XXX_Size() int {
	return xxx_messageInfo_NetworkSetting.Size(m)
}
func (m *NetworkSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkSetting.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkSetting proto.InternalMessageInfo

func (m *NetworkSetting) GetStatus() NetworkSetting_Status {
	if m != nil {
		return m.Status
	}
	return NetworkSetting_NONE
}

func (m *NetworkSetting) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *NetworkSetting) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

func (m *NetworkSetting) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *NetworkSetting) GetDns() []string {
	if m != nil {
		return m.Dns
	}
	return nil
}

type LifecycleCommand struct {
	Id                   string                   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Cmd                  LifecycleCommand_Command `protobuf:"varint,2,opt,name=cmd,proto3,enum=openness.ela.LifecycleCommand_Command" json:"cmd,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LifecycleCommand) Reset()         { *m = LifecycleCommand{} }
func (m *LifecycleCommand) String() string { return proto.CompactTextString(m) }
func (*LifecycleCommand) ProtoMessage()    {}
func (*LifecycleCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{18}
}

func (m *LifecycleCommand) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LifecycleCommand.Unmarshal(m, b)
}
func (m *LifecycleCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LifecycleCommand.Marshal(b, m, deterministic)
}
func (m *LifecycleCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LifecycleCommand.Merge(m, src)
}
func (m *LifecycleCommand) XXX_Size() int {
	return xxx_messageInfo_LifecycleCommand.Size(m)
}
func (m *LifecycleCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_LifecycleCommand.DiscardUnknown(m)
}

var xxx_messageInfo_LifecycleCommand proto.InternalMessageInfo

func (m *LifecycleCommand) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LifecycleCommand) GetCmd() LifecycleCommand_Command {
	if m != nil {
		return m.Cmd
	}
	return LifecycleCommand_START
}

type ApplicationID struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApplicationID) Reset()         { *m = ApplicationID{} }
func (m *ApplicationID) String() string { return proto.CompactTextString(m) }
func (*ApplicationID) ProtoMessage()    {}
func (*ApplicationID) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{19}
}

func (m *ApplicationID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ApplicationID.Unmarshal(m, b)
}
func (m *ApplicationID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ApplicationID.Marshal(b, m, deterministic)
}
func (m *ApplicationID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationID.Merge(m, src)
}
func (m *ApplicationID) XXX_Size() int {
	return xxx_messageInfo_ApplicationID.Size(m)
}
func (m *ApplicationID) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationID.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationID proto.InternalMessageInfo

func (m *ApplicationID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type InterfaceID struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfaceID) Reset()         { *m = InterfaceID{} }
func (m *InterfaceID) String() string { return proto.CompactTextString(m) }
func (*InterfaceID) ProtoMessage()    {}
func (*InterfaceID) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{20}
}

func (m *InterfaceID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InterfaceID.Unmarshal(m, b)
}
func (m *InterfaceID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InterfaceID.Marshal(b, m, deterministic)
}
func (m *InterfaceID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceID.Merge(m, src)
}
func (m *InterfaceID) XXX_Size() int {
	return xxx_messageInfo_InterfaceID.Size(m)
}
func (m *InterfaceID) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceID.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceID proto.InternalMessageInfo

func (m *InterfaceID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type VNFID struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VNFID) Reset()         { *m = VNFID{} }
func (m *VNFID) String() string { return proto.CompactTextString(m) }
func (*VNFID) ProtoMessage()    {}
func (*VNFID) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{21}
}

func (m *VNFID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VNFID.Unmarshal(m, b)
}
func (m *VNFID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VNFID.Marshal(b, m, deterministic)
}
func (m *VNFID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VNFID.Merge(m, src)
}
func (m *VNFID) XXX_Size() int {
	return xxx_messageInfo_VNFID.Size(m)
}
func (m *VNFID) XXX_DiscardUnknown() {
	xxx_messageInfo_VNFID.DiscardUnknown(m)
}

var xxx_messageInfo_VNFID proto.InternalMessageInfo

func (m *VNFID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ZoneID struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZoneID) Reset()         { *m = ZoneID{} }
func (m *ZoneID) String() string { return proto.CompactTextString(m) }
func (*ZoneID) ProtoMessage()    {}
func (*ZoneID) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{22}
}

func (m *ZoneID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ZoneID.Unmarshal(m, b)
}
func (m *ZoneID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ZoneID.Marshal(b, m, deterministic)
}
func (m *ZoneID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZoneID.Merge(m, src)
}
func (m *ZoneID) XXX_Size() int {
	return xxx_messageInfo_ZoneID.Size(m)
}
func (m *ZoneID) XXX_DiscardUnknown() {
	xxx_messageInfo_ZoneID.DiscardUnknown(m)
}

var xxx_messageInfo_ZoneID proto.InternalMessageInfo

func (m *ZoneID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func init() {
	proto.RegisterEnum("openness.ela.LifecycleStatus", LifecycleStatus_name, LifecycleStatus_value)
	proto.RegisterEnum("openness.ela.TrafficTarget_TargetAction", TrafficTarget_TargetAction_name, TrafficTarget_TargetAction_value)
	proto.RegisterEnum("openness.ela.NetworkInterface_InterfaceDriver", NetworkInterface_InterfaceDriver_name, NetworkInterface_InterfaceDriver_value)
	proto.RegisterEnum("openness.ela.NetworkInterface_InterfaceType", NetworkInterface_InterfaceType_name, NetworkInterface_InterfaceType_value)
	proto.RegisterEnum("openness.ela.NetworkSetting_Status", NetworkSetting_Status_name, NetworkSetting_Status_value)
	proto.RegisterEnum("openness.ela.LifecycleCommand_Command", LifecycleCommand_Command_name, LifecycleCommand_Command_value)
	proto.RegisterType((*Application)(nil), "openness.ela.Application")
	proto.RegisterType((*Applications)(nil), "openness.ela.Applications")
	proto.RegisterType((*VNF)(nil), "openness.ela.VNF")
	proto.RegisterType((*VNFs)(nil), "openness.ela.VNFs")
	proto.RegisterType((*TrafficPolicy)(nil), "openness.ela.TrafficPolicy")
	proto.RegisterType((*TrafficRule)(nil), "openness.ela.TrafficRule")
	proto.RegisterType((*TrafficSelector)(nil), "openness.ela.TrafficSelector")
	proto.RegisterType((*MACFilter)(nil), "openness.ela.MACFilter")
	proto.RegisterType((*IPFilter)(nil), "openness.ela.IPFilter")
	proto.RegisterType((*GTPFilter)(nil), "openness.ela.GTPFilter")
	proto.RegisterType((*TrafficTarget)(nil), "openness.ela.TrafficTarget")
	proto.RegisterType((*MACModifier)(nil), "openness.ela.MACModifier")
	proto.RegisterType((*IPModifier)(nil), "openness.ela.IPModifier")
	proto.RegisterType((*NetworkInterface)(nil), "openness.ela.NetworkInterface")
	proto.RegisterType((*NetworkInterfaces)(nil), "openness.ela.NetworkInterfaces")
	proto.RegisterType((*NetworkZone)(nil), "openness.ela.NetworkZone")
	proto.RegisterType((*NetworkZones)(nil), "openness.ela.NetworkZones")
	proto.RegisterType((*NetworkSetting)(nil), "openness.ela.NetworkSetting")
	proto.RegisterType((*LifecycleCommand)(nil), "openness.ela.LifecycleCommand")
	proto.RegisterType((*ApplicationID)(nil), "openness.ela.ApplicationID")
	proto.RegisterType((*InterfaceID)(nil), "openness.ela.InterfaceID")
	proto.RegisterType((*VNFID)(nil), "openness.ela.VNFID")
	proto.RegisterType((*ZoneID)(nil), "openness.ela.ZoneID")
}

func init() { proto.RegisterFile("ela.proto", fileDescriptor_eb26205266db6e19) }

var fileDescriptor_eb26205266db6e19 = []byte{
	// 2923 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x59, 0xcb, 0x73, 0x1b, 0x59,
	0xd5, 0x4f, 0x4b, 0xb6, 0x6c, 0x1f, 0x59, 0x89, 0x72, 0xe3, 0x87, 0xd2, 0xf1, 0xa3, 0xd3, 0x9e,
	0xc9, 0x78, 0x1c, 0x5b, 0xf2, 0x28, 0x9e, 0xef, 0x91, 0x6f, 0x1e, 0xe9, 0xc8, 0x72, 0x3e, 0x79,
	0x6c, 0xd9, 0xb4, 0x64, 0xcf, 0x10, 0x16, 0xa1, 0xd5, 0xba, 0x56, 0x7a, 0xd2, 0xea, 0x56, 0x75,
	0xb7, 0x9c, 0xf2, 0x4c, 0x01, 0x55, 0xbc, 0xaa, 0x60, 0x01, 0x83, 0x86, 0xa2, 0x86, 0x02, 0x86,
	0xc5, 0x50, 0x53, 0xc5, 0x82, 0xd5, 0x14, 0x0b, 0x8a, 0x15, 0x2c, 0x60, 0x76, 0x50, 0xb0, 0xa3,
	0x28, 0xd8, 0x50, 0x14, 0xf0, 0x17, 0x40, 0xc1, 0x82, 0xba, 0xf7, 0xb6, 0x5a, 0xdd, 0x6a, 0xb5,
	0xec, 0xc4, 0x3b, 0x56, 0xea, 0x7b, 0xcf, 0x39, 0xf7, 0xfc, 0xce, 0xe3, 0x9e, 0x73, 0xef, 0x15,
	0x4c, 0x60, 0x5d, 0xc9, 0xb6, 0x2c, 0xd3, 0x31, 0xd1, 0xa4, 0xd9, 0xc2, 0x86, 0x81, 0x6d, 0x3b,
	0x8b, 0x75, 0x85, 0xbf, 0xd6, 0x30, 0xcd, 0x86, 0x8e, 0x73, 0x94, 0x56, 0x6b, 0x1f, 0xe5, 0x70,
	0xb3, 0xe5, 0x9c, 0x30, 0x56, 0x7e, 0xce, 0x25, 0x2a, 0x2d, 0x2d, 0xa7, 0x18, 0x86, 0xe9, 0x28,
	0x8e, 0x66, 0x1a, 0xb6, 0x4b, 0x5d, 0xa5, 0x3f, 0xea, 0x5a, 0x03, 0x1b, 0x6b, 0xf6, 0x63, 0xa5,
	0xd1, 0xc0, 0x56, 0xce, 0x6c, 0x51, 0x8e, 0x30, 0xb7, 0xf8, 0x67, 0x0e, 0x92, 0x52, 0xab, 0xa5,
	0x6b, 0x2a, 0x9d, 0x46, 0x17, 0x21, 0xa6, 0xd5, 0x33, 0x9c, 0xc0, 0x2d, 0x4f, 0xc8, 0x31, 0xad,
	0x8e, 0x10, 0x8c, 0x18, 0x4a, 0x13, 0x67, 0x62, 0x74, 0x86, 0x7e, 0xa3, 0x19, 0x48, 0x1c, 0x63,
	0xa3, 0x6e, 0x5a, 0x99, 0x38, 0x9d, 0x75, 0x47, 0x48, 0x80, 0x64, 0x1d, 0xdb, 0xaa, 0xa5, 0x51,
	0x6d, 0x99, 0x11, 0x4a, 0xf4, 0x4f, 0xa1, 0x29, 0x18, 0xd5, 0x9a, 0x4a, 0x03, 0x67, 0x46, 0x29,
	0x8d, 0x0d, 0xc8, 0xac, 0x6a, 0x5a, 0xd8, 0xce, 0x24, 0x04, 0x6e, 0x79, 0x54, 0x66, 0x03, 0xa2,
	0xa5, 0x89, 0x9b, 0xa6, 0x75, 0x92, 0x19, 0xa3, 0xd3, 0xee, 0x08, 0xbd, 0x08, 0x09, 0xdb, 0x51,
	0x9c, 0xb6, 0x9d, 0x19, 0x17, 0xb8, 0xe5, 0x8b, 0xf9, 0xf9, 0xac, 0xdf, 0x73, 0xd9, 0x1d, 0xed,
	0x08, 0xab, 0x27, 0xaa, 0x8e, 0x2b, 0x94, 0x49, 0x76, 0x99, 0xc5, 0x5d, 0x98, 0xf4, 0xd9, 0x69,
	0xa3, 0x97, 0x61, 0x52, 0xf1, 0x8d, 0x33, 0x9c, 0x10, 0x5f, 0x4e, 0xe6, 0xaf, 0x06, 0x17, 0xf3,
	0x49, 0xc8, 0x01, 0x76, 0xf1, 0x0f, 0x1c, 0xc4, 0x0f, 0xcb, 0x5b, 0xff, 0xb9, 0xfe, 0x5a, 0x83,
	0x91, 0xc3, 0xf2, 0x96, 0x8d, 0x9e, 0x85, 0x91, 0x63, 0xe3, 0xa8, 0xeb, 0x9f, 0xcb, 0x41, 0xe1,
	0xc3, 0xf2, 0x96, 0x4c, 0xc9, 0xe2, 0x03, 0x48, 0x55, 0x2d, 0xe5, 0xe8, 0x48, 0x53, 0xf7, 0x4d,
	0x5d, 0x53, 0x4f, 0x42, 0x8e, 0x79, 0x05, 0x52, 0x0e, 0x63, 0x78, 0x60, 0xb5, 0x75, 0x6c, 0x67,
	0x62, 0x83, 0x1c, 0xee, 0xae, 0x21, 0xb7, 0x75, 0x2c, 0x4f, 0x3a, 0xbd, 0x81, 0x2d, 0xfe, 0x9d,
	0x83, 0xa4, 0x8f, 0xda, 0xef, 0x3c, 0x2e, 0xec, 0x3c, 0x1e, 0xc6, 0x5b, 0x96, 0x66, 0x5a, 0x9a,
	0x73, 0x42, 0xc3, 0x91, 0x92, 0xbd, 0x31, 0x75, 0x8a, 0xd9, 0xb6, 0x54, 0x4c, 0x43, 0x92, 0xec,
	0x77, 0x8a, 0xab, 0xa8, 0x82, 0x75, 0xac, 0x3a, 0xa6, 0x25, 0xbb, 0xcc, 0xe8, 0x55, 0xaa, 0xd4,
	0xd1, 0x0c, 0xc5, 0x8b, 0xd8, 0xa9, 0xb2, 0x7e, 0x09, 0x74, 0x0b, 0x12, 0x8e, 0x62, 0x35, 0xb0,
	0x43, 0x23, 0x9a, 0xcc, 0x5f, 0x1b, 0x28, 0x5b, 0xa5, 0x2c, 0xb2, 0xcb, 0x2a, 0x7e, 0xc4, 0xc1,
	0xa5, 0xbe, 0x55, 0xcf, 0x60, 0xfe, 0x4d, 0x18, 0x69, 0x2a, 0xaa, 0x4d, 0x4d, 0x4f, 0xe6, 0x67,
	0x83, 0x8a, 0x76, 0xa5, 0xc2, 0x96, 0xa6, 0x3b, 0xd8, 0x92, 0x29, 0x13, 0xba, 0x01, 0x31, 0xad,
	0xe5, 0xfa, 0x62, 0x26, 0xc8, 0x5a, 0xda, 0x77, 0x39, 0x63, 0x5a, 0x0b, 0x3d, 0x0f, 0xf1, 0x86,
	0xd3, 0x72, 0x0d, 0xef, 0x5b, 0xf3, 0x5e, 0xb5, 0xcb, 0x49, 0x78, 0xc4, 0x75, 0x98, 0xf0, 0xb4,
	0xa0, 0x25, 0x48, 0x35, 0x15, 0xf5, 0x81, 0x52, 0xaf, 0x5b, 0xd8, 0xb6, 0x31, 0x4b, 0xa7, 0x09,
	0x79, 0xb2, 0xa9, 0xa8, 0x52, 0x77, 0x4e, 0xfc, 0x1a, 0x07, 0xe3, 0x5d, 0x6d, 0x28, 0x03, 0x63,
	0x2e, 0xb7, 0x6b, 0x5c, 0x77, 0x48, 0xb6, 0x58, 0x53, 0xb1, 0x1f, 0xb9, 0x31, 0xa5, 0xdf, 0x68,
	0x1e, 0xa0, 0x86, 0x1b, 0x9a, 0xf1, 0xa0, 0x65, 0x5a, 0x0e, 0xb5, 0x23, 0x25, 0x4f, 0xd0, 0x99,
	0x7d, 0xd3, 0x72, 0xd0, 0x55, 0x18, 0xc7, 0x46, 0x9d, 0x11, 0x47, 0x28, 0x71, 0x0c, 0x1b, 0x75,
	0x4a, 0xa2, 0x59, 0x42, 0x0a, 0xa6, 0xa9, 0xbb, 0xbb, 0xcc, 0x1b, 0x8b, 0x7b, 0x30, 0xe1, 0x19,
	0xf5, 0x84, 0x80, 0xe8, 0xce, 0xb5, 0x35, 0x3b, 0x13, 0xa7, 0x86, 0xb2, 0x81, 0xf8, 0x2f, 0xce,
	0xdb, 0x26, 0x2c, 0xc6, 0x67, 0x88, 0xe3, 0x1d, 0x48, 0x28, 0x2a, 0x25, 0xc6, 0xe8, 0xfe, 0x5d,
	0x1e, 0x92, 0x32, 0x59, 0xf6, 0x23, 0x51, 0x7e, 0xd9, 0x95, 0x43, 0x37, 0x21, 0xde, 0x54, 0x54,
	0x37, 0xba, 0x57, 0x43, 0x89, 0xb0, 0x6b, 0xd6, 0xb5, 0x23, 0x8d, 0x84, 0xad, 0xa9, 0xa8, 0x68,
	0x99, 0x66, 0x02, 0x0b, 0x70, 0xa6, 0x3f, 0x13, 0x3c, 0xd6, 0x98, 0x46, 0x02, 0x3c, 0xe9, 0x57,
	0x87, 0x00, 0x12, 0x52, 0xa1, 0x50, 0xdc, 0xaf, 0xa6, 0x2f, 0x90, 0x6f, 0xb9, 0xb8, 0x5d, 0x2c,
	0x54, 0xd3, 0x1c, 0x1a, 0x87, 0x91, 0x4d, 0x79, 0x6f, 0x3f, 0x1d, 0x13, 0xb3, 0x90, 0xf4, 0xe9,
	0x43, 0x8b, 0x90, 0xf4, 0x25, 0x85, 0x6b, 0x3b, 0xf4, 0x52, 0x42, 0xbc, 0x0d, 0xd0, 0xd3, 0x39,
	0x3c, 0x00, 0x34, 0xb4, 0x6e, 0x00, 0xc8, 0xb7, 0xf8, 0xeb, 0x38, 0xa4, 0xcb, 0xd8, 0x79, 0x6c,
	0x5a, 0x8f, 0x4a, 0x86, 0x83, 0xad, 0x23, 0x45, 0xc5, 0xa1, 0xa2, 0xd4, 0xe7, 0xfd, 0x58, 0xd8,
	0xfb, 0x5b, 0x90, 0xa8, 0x5b, 0xda, 0x31, 0x66, 0xb5, 0xfb, 0x62, 0x3e, 0x1b, 0x74, 0x49, 0xbf,
	0x86, 0xac, 0xf7, 0xb5, 0x49, 0xa5, 0x64, 0x57, 0x1a, 0xdd, 0x81, 0x11, 0xe7, 0xa4, 0x85, 0xa9,
	0x63, 0x2f, 0xe6, 0x57, 0xcf, 0xba, 0x4a, 0xf5, 0xa4, 0x85, 0x65, 0x2a, 0xd9, 0xef, 0xad, 0xd1,
	0x7e, 0x6f, 0x11, 0x2f, 0x1c, 0xeb, 0x8a, 0x41, 0xbb, 0x42, 0x4a, 0xa6, 0xdf, 0x24, 0x0d, 0xdf,
	0x32, 0x0d, 0x6c, 0x67, 0xc6, 0x58, 0x1a, 0xd2, 0x01, 0x5a, 0x03, 0x74, 0xa4, 0xe8, 0x7a, 0x4d,
	0x51, 0x1f, 0x3d, 0xd0, 0xba, 0xaa, 0x68, 0x7b, 0x98, 0x90, 0x2f, 0x77, 0x29, 0x1e, 0x06, 0x71,
	0x15, 0x2e, 0xf5, 0x99, 0x45, 0xe2, 0xfb, 0x5a, 0x51, 0x2e, 0x17, 0x77, 0xd2, 0x17, 0x50, 0x0a,
	0x26, 0x0e, 0x2a, 0x45, 0xb9, 0xb2, 0x2f, 0x15, 0x8a, 0x69, 0x4e, 0x7c, 0x03, 0x52, 0x01, 0xf8,
	0x24, 0xfe, 0xe5, 0xbd, 0x72, 0x31, 0x7d, 0x01, 0x4d, 0xc2, 0xf8, 0xc1, 0x7e, 0xa5, 0x2a, 0x17,
	0xa5, 0xdd, 0x34, 0x87, 0x2e, 0x02, 0x6c, 0xee, 0xbd, 0x5e, 0x76, 0xc7, 0x31, 0x74, 0x19, 0x52,
	0x77, 0x4b, 0x9b, 0x25, 0xb9, 0x58, 0xa8, 0x96, 0xf6, 0xca, 0xd2, 0x4e, 0x3a, 0x4e, 0x04, 0xee,
	0xca, 0x45, 0xe9, 0xb5, 0xbd, 0x83, 0x6a, 0x7a, 0x44, 0xac, 0xc1, 0xe5, 0x7e, 0x4f, 0xd9, 0x68,
	0x17, 0x90, 0xc1, 0x26, 0x7b, 0xa6, 0x74, 0xbb, 0xd5, 0xc2, 0x70, 0x37, 0xcb, 0x97, 0x8d, 0xfe,
	0xe5, 0xc4, 0x57, 0x21, 0xe9, 0xb2, 0xdd, 0x37, 0x8d, 0xa7, 0x48, 0x18, 0xb1, 0x0c, 0x93, 0xbe,
	0x05, 0x6c, 0xd2, 0xf7, 0xba, 0xf8, 0x58, 0x24, 0x06, 0x1e, 0x34, 0x7c, 0x22, 0xf2, 0xa4, 0xe1,
	0x93, 0x17, 0xff, 0xc6, 0xc1, 0x45, 0x97, 0x5a, 0xc1, 0x8e, 0xa3, 0x19, 0x0d, 0xf4, 0x7f, 0x5e,
	0x47, 0xe7, 0x68, 0x36, 0x2d, 0x0d, 0x5c, 0xcb, 0xe5, 0xce, 0x06, 0xfb, 0xba, 0x7f, 0x17, 0xc5,
	0x06, 0x97, 0xb1, 0xb8, 0xaf, 0x8c, 0x65, 0x60, 0xac, 0xa1, 0x38, 0xf8, 0xb1, 0x72, 0xe2, 0x1e,
	0x4f, 0xba, 0x43, 0x94, 0x86, 0x78, 0xdd, 0x20, 0x69, 0x48, 0xf2, 0x8a, 0x7c, 0x8a, 0x12, 0x24,
	0x98, 0x2e, 0x5f, 0xc4, 0x01, 0x12, 0x95, 0xaa, 0x54, 0x2d, 0x15, 0xd2, 0x1c, 0xf9, 0xde, 0xfc,
	0xff, 0xc2, 0xfe, 0xf1, 0x46, 0x3a, 0xe6, 0x7d, 0xff, 0x57, 0x3a, 0x8e, 0x26, 0x60, 0xb4, 0xb2,
	0x23, 0x49, 0x85, 0xf4, 0x88, 0xf8, 0x15, 0x0e, 0xd2, 0xde, 0x81, 0xa4, 0x60, 0x36, 0x9b, 0x8a,
	0x51, 0x0f, 0xc5, 0xe0, 0x7f, 0x20, 0xae, 0x36, 0xeb, 0x6e, 0x35, 0xbc, 0x11, 0x71, 0x9a, 0x71,
	0x85, 0xb3, 0xee, 0xaf, 0x4c, 0x44, 0xc4, 0x9b, 0x30, 0xd6, 0x5d, 0x94, 0x28, 0xad, 0x4a, 0x32,
	0xa9, 0x55, 0xe3, 0x30, 0x52, 0xa9, 0xee, 0xed, 0xa7, 0x39, 0x94, 0x84, 0x31, 0xb9, 0xc8, 0xa6,
	0x63, 0xe2, 0x22, 0xa4, 0x7c, 0xc7, 0xbf, 0xd2, 0x66, 0x3f, 0x0e, 0x71, 0x1e, 0x92, 0x5e, 0xe2,
	0x0c, 0x20, 0xcf, 0xc2, 0xe8, 0x61, 0x79, 0x6b, 0x00, 0x21, 0x03, 0x09, 0x12, 0xda, 0x30, 0x65,
	0xe5, 0x4d, 0xb8, 0xd4, 0x77, 0x1c, 0x23, 0x90, 0x0e, 0xca, 0xaf, 0x95, 0xf7, 0x5e, 0x2f, 0xa7,
	0x2f, 0x10, 0xd0, 0x72, 0x51, 0xda, 0xfc, 0x64, 0x9a, 0x23, 0x3b, 0x83, 0x02, 0x2d, 0x95, 0xef,
	0xa5, 0x63, 0x14, 0xf8, 0x41, 0xb9, 0x4c, 0x06, 0x71, 0x46, 0xda, 0xdb, 0xdf, 0x27, 0xa3, 0x11,
	0x42, 0xa2, 0xa3, 0xe2, 0x66, 0x7a, 0x94, 0x2c, 0x50, 0x94, 0xe5, 0x3d, 0x39, 0x9d, 0xc8, 0x7f,
	0x38, 0x01, 0x73, 0x3e, 0xfb, 0x36, 0x71, 0x4b, 0x37, 0x4f, 0x9a, 0xd8, 0x70, 0x2a, 0xd8, 0x3a,
	0xd6, 0x54, 0x8c, 0x7e, 0xca, 0xc1, 0x25, 0x36, 0x5b, 0x30, 0x0d, 0x47, 0xd1, 0x0c, 0x6c, 0xa1,
	0xe8, 0xe3, 0x31, 0x7f, 0x2d, 0x92, 0x54, 0xda, 0x14, 0x5b, 0x1d, 0xe9, 0x80, 0x5f, 0x60, 0xab,
	0x09, 0x8a, 0xa0, 0x76, 0x17, 0x14, 0x7c, 0x67, 0xea, 0xed, 0x5b, 0x10, 0xcf, 0xaf, 0xe7, 0xd1,
	0x2a, 0xac, 0x14, 0x06, 0xd1, 0x85, 0xba, 0x07, 0x51, 0x50, 0xcd, 0x66, 0x13, 0x1b, 0x2a, 0xae,
	0x7f, 0xfe, 0xb7, 0x7f, 0x7a, 0x37, 0x86, 0xc4, 0x54, 0xce, 0x7f, 0x38, 0xbf, 0xcd, 0xad, 0xa0,
	0x0f, 0x39, 0x18, 0x67, 0xfa, 0x0e, 0x77, 0x9f, 0x1a, 0x76, 0xad, 0x23, 0xdd, 0xe3, 0x67, 0x3d,
	0xd8, 0x87, 0xbb, 0x01, 0xbc, 0xab, 0x0c, 0xef, 0xb3, 0xb0, 0x14, 0x24, 0x3c, 0x19, 0xd0, 0x0f,
	0x38, 0x48, 0xdc, 0xc3, 0x8e, 0xa4, 0xeb, 0x68, 0x26, 0xcb, 0x2e, 0x76, 0xd9, 0xee, 0xad, 0x2f,
	0x5b, 0x24, 0xb7, 0x3e, 0x9e, 0x8f, 0xc4, 0x68, 0x8b, 0xb8, 0x23, 0xbd, 0xca, 0x8b, 0x32, 0x76,
	0x2c, 0x0d, 0x1f, 0x63, 0x41, 0xd1, 0x75, 0x57, 0x3d, 0xae, 0xfb, 0x31, 0xd9, 0xdb, 0x57, 0x09,
	0xda, 0x75, 0x84, 0x20, 0xed, 0x93, 0x17, 0x74, 0xcd, 0x76, 0x28, 0xb4, 0x79, 0x14, 0x84, 0x56,
	0x0b, 0x5c, 0x77, 0xd0, 0x47, 0x1c, 0xc4, 0xef, 0x61, 0x07, 0x0d, 0x73, 0x17, 0x1f, 0xed, 0x66,
	0xd1, 0xe9, 0x48, 0xaf, 0xf3, 0x8b, 0x3d, 0x98, 0x03, 0x41, 0x6e, 0x4f, 0x31, 0x8c, 0xa9, 0xc0,
	0x95, 0x74, 0x7b, 0x01, 0xe2, 0x1b, 0xeb, 0x1b, 0x68, 0x16, 0xa6, 0xfd, 0xc8, 0x0d, 0xd3, 0x11,
	0x8e, 0xcc, 0xb6, 0xc1, 0x3c, 0x3b, 0x85, 0x50, 0x00, 0x7e, 0xee, 0x6d, 0xad, 0xfe, 0x19, 0xf4,
	0x0b, 0x0e, 0xc6, 0x65, 0xcc, 0x54, 0x0d, 0x4b, 0x82, 0x08, 0xc7, 0x8b, 0x5f, 0xe6, 0x3a, 0xd2,
	0x11, 0x3f, 0xdb, 0x5d, 0x42, 0x50, 0x8c, 0x00, 0xdc, 0x9b, 0x2c, 0x01, 0x9e, 0x01, 0xd1, 0x0f,
	0xcc, 0xc2, 0x83, 0xe2, 0x7f, 0x26, 0x2b, 0x66, 0xf3, 0x03, 0xac, 0x20, 0x49, 0xf2, 0x0f, 0x0e,
	0x12, 0x32, 0x6e, 0x9a, 0xc7, 0x78, 0x78, 0x04, 0xa2, 0x0c, 0xf9, 0x09, 0xd7, 0x91, 0xbe, 0xc3,
	0xf1, 0xf3, 0x6c, 0x8d, 0x28, 0xf7, 0xcf, 0x11, 0x7b, 0x36, 0xd0, 0x34, 0x5c, 0x09, 0xda, 0x43,
	0x64, 0x4e, 0x35, 0x60, 0xfb, 0x25, 0x42, 0xff, 0x5f, 0xf4, 0x22, 0xdc, 0x0a, 0x48, 0xb7, 0x0d,
	0x43, 0x33, 0x1a, 0xab, 0x42, 0xb3, 0x6d, 0x3b, 0x42, 0x0d, 0x0b, 0xb6, 0x63, 0xb6, 0x5a, 0xb8,
	0x2e, 0xd4, 0xf0, 0x91, 0x69, 0x61, 0xb6, 0xba, 0xa2, 0xb3, 0x20, 0xae, 0x0c, 0x30, 0x3f, 0xff,
	0xc3, 0x04, 0x5c, 0xf3, 0xad, 0xd8, 0x2b, 0x90, 0x6e, 0x9d, 0xfa, 0x27, 0x07, 0xa3, 0x15, 0x47,
	0xb1, 0x1c, 0xb4, 0x30, 0xbc, 0x17, 0x0c, 0xf5, 0xce, 0xb7, 0x38, 0x7e, 0x8e, 0xae, 0x12, 0xe5,
	0x9c, 0x67, 0x58, 0xb0, 0xe7, 0x03, 0x60, 0x04, 0x9b, 0x8a, 0xf4, 0xa2, 0xbc, 0xce, 0x5c, 0xf8,
	0x3c, 0x3c, 0xe7, 0xe7, 0x52, 0x74, 0x0b, 0x2b, 0xf5, 0x93, 0xae, 0x33, 0x04, 0xd3, 0x62, 0x82,
	0x9a, 0xd1, 0x38, 0x53, 0x5e, 0x5c, 0x1d, 0x98, 0x17, 0xa4, 0xa5, 0xa1, 0x2f, 0xc4, 0x60, 0xa4,
	0xe2, 0x98, 0xad, 0xa7, 0x36, 0xfe, 0xe7, 0x5c, 0x47, 0xfa, 0x3e, 0xc7, 0x5f, 0x23, 0x8b, 0x44,
	0xd9, 0xfe, 0x1c, 0xb3, 0x5d, 0x80, 0x85, 0x80, 0xed, 0x0f, 0xdb, 0x4e, 0xdd, 0x7c, 0x6c, 0xf8,
	0xcc, 0xff, 0x6f, 0x66, 0xfe, 0x3a, 0x64, 0x07, 0x99, 0x4f, 0x04, 0x04, 0x2a, 0x41, 0x1c, 0xf0,
	0xb0, 0x4d, 0xcf, 0x27, 0x74, 0xe2, 0xbc, 0x5e, 0xf8, 0x52, 0x0c, 0xc6, 0x64, 0x6c, 0x9f, 0x2b,
	0x0b, 0x7e, 0xc6, 0x75, 0xa4, 0xf7, 0x39, 0x7e, 0xc1, 0x5d, 0x27, 0xca, 0x17, 0x37, 0x98, 0x2f,
	0x16, 0x61, 0x3e, 0xb8, 0x49, 0xfa, 0x33, 0x61, 0x83, 0xb9, 0x62, 0x0d, 0x6e, 0x0e, 0xcc, 0x04,
	0xc6, 0x8f, 0xeb, 0xc4, 0x15, 0xee, 0xe0, 0xfc, 0xd9, 0x90, 0xff, 0xeb, 0x28, 0x4c, 0x1d, 0x96,
	0xb7, 0xc2, 0xcd, 0xfc, 0x18, 0x12, 0x6c, 0x12, 0x85, 0x5f, 0x70, 0xf8, 0x2b, 0xa1, 0xa9, 0xd2,
	0xa6, 0xb8, 0xd9, 0x91, 0x5e, 0xe0, 0x27, 0x7b, 0xbd, 0xaf, 0xbc, 0xb5, 0x7d, 0x9d, 0x99, 0xce,
	0x43, 0xe6, 0xb0, 0xbc, 0x15, 0xdd, 0xe5, 0x40, 0x1c, 0xcd, 0x1d, 0x1b, 0x47, 0xb4, 0xbb, 0xbd,
	0x7d, 0x6a, 0x73, 0x43, 0x21, 0xe5, 0xb6, 0x58, 0xec, 0x48, 0x39, 0x9e, 0x1f, 0xdc, 0xd4, 0x08,
	0xc3, 0xf6, 0x65, 0xd6, 0x28, 0x00, 0xc6, 0x09, 0x12, 0xaf, 0x89, 0xa5, 0x10, 0xd3, 0x5c, 0xa3,
	0x6f, 0x52, 0xe8, 0x11, 0xeb, 0x59, 0x83, 0xcc, 0xe3, 0xc3, 0x6e, 0x10, 0x5f, 0xea, 0x48, 0xcf,
	0x91, 0x62, 0x1f, 0xee, 0x51, 0xc4, 0xf8, 0x49, 0xa6, 0x72, 0x94, 0x3e, 0xfb, 0x51, 0x6d, 0x93,
	0x08, 0xa8, 0x36, 0xd6, 0x6b, 0x3e, 0xf0, 0xf7, 0x9a, 0x01, 0x4e, 0x8e, 0x4a, 0x3b, 0xbd, 0x23,
	0x55, 0xf9, 0xe9, 0x83, 0x56, 0x5d, 0x71, 0x42, 0x3a, 0x97, 0x98, 0xc3, 0xe7, 0x80, 0x27, 0x66,
	0x46, 0x34, 0x96, 0x19, 0x96, 0x32, 0x97, 0x20, 0x45, 0x98, 0x82, 0xa9, 0x72, 0x29, 0xef, 0x83,
	0x48, 0xe2, 0xf1, 0x71, 0xaf, 0x91, 0x0c, 0x74, 0x4b, 0x14, 0xca, 0x77, 0xb8, 0x8e, 0xf4, 0x36,
	0x3f, 0x1d, 0xee, 0x1f, 0x04, 0xe6, 0x14, 0x4b, 0xf5, 0x14, 0x24, 0x19, 0x4c, 0xd6, 0x2f, 0x22,
	0x70, 0x91, 0x8d, 0x41, 0xfa, 0xc4, 0x1a, 0xdc, 0xa4, 0xdc, 0x4f, 0xd0, 0x1f, 0x26, 0x57, 0x7c,
	0xd6, 0xe4, 0x3f, 0x1c, 0x85, 0x2b, 0x87, 0xe5, 0xad, 0x50, 0x3f, 0xf8, 0xcd, 0xb9, 0xfb, 0x01,
	0x31, 0xf6, 0x98, 0x9f, 0x0a, 0xb5, 0x03, 0x62, 0xeb, 0x1c, 0x0b, 0xc9, 0x34, 0xd5, 0x1d, 0x2a,
	0xff, 0xcb, 0xcc, 0x13, 0xd7, 0x61, 0x91, 0x50, 0x87, 0x95, 0xfd, 0x61, 0x51, 0xbb, 0x1c, 0x88,
	0x1a, 0x2d, 0x70, 0xbf, 0xe3, 0xce, 0x59, 0xe6, 0xbf, 0xcd, 0x75, 0xa4, 0xcf, 0xf1, 0x57, 0xfa,
	0xab, 0x3c, 0x31, 0x69, 0x91, 0x99, 0x94, 0x81, 0x19, 0x6a, 0x52, 0xb8, 0xaa, 0xe7, 0x98, 0x55,
	0xcb, 0x70, 0xc3, 0x6f, 0xd5, 0x90, 0x6a, 0xfe, 0x84, 0xc6, 0xfd, 0x9e, 0x3b, 0x7f, 0xf5, 0x7e,
	0x8f, 0xeb, 0x48, 0x9f, 0xe5, 0x67, 0x06, 0x14, 0x6f, 0x62, 0xe2, 0x02, 0x33, 0x71, 0x16, 0xa6,
	0x59, 0x86, 0xf6, 0xc7, 0x6d, 0x95, 0x59, 0x48, 0x8e, 0xf2, 0xfe, 0xb8, 0x45, 0x14, 0xe9, 0x27,
	0x33, 0x2f, 0xff, 0xcb, 0x51, 0x48, 0x7b, 0x17, 0xc5, 0x6e, 0x96, 0xfe, 0x88, 0x83, 0x04, 0xdb,
	0xf4, 0xe8, 0x94, 0x57, 0x8a, 0x48, 0x93, 0x1f, 0x75, 0xa4, 0x5d, 0xfe, 0x7a, 0xb7, 0x72, 0x18,
	0x82, 0xf7, 0xfc, 0x41, 0xee, 0x57, 0x47, 0x5a, 0xa3, 0x6d, 0xb1, 0x8e, 0xd5, 0x4b, 0xca, 0xd2,
	0x60, 0x0e, 0xa1, 0x4d, 0xd7, 0x60, 0x06, 0x4c, 0xe7, 0xd3, 0xb9, 0xde, 0x43, 0x8a, 0x57, 0x38,
	0x7e, 0xcc, 0x01, 0xdc, 0x6d, 0xeb, 0x8f, 0x5c, 0xcc, 0x8b, 0xc3, 0x31, 0xdb, 0x91, 0xa0, 0x0d,
	0x72, 0x13, 0x5c, 0x76, 0x41, 0x37, 0xdb, 0xba, 0xa3, 0xb5, 0x74, 0x1c, 0x05, 0xdd, 0xde, 0x7e,
	0x9e, 0x61, 0x17, 0x41, 0x88, 0xc0, 0x6e, 0x07, 0xc0, 0xa7, 0xf3, 0x49, 0x1f, 0xf8, 0x33, 0x5e,
	0xaf, 0x4e, 0xb3, 0x45, 0xfc, 0x74, 0x47, 0xda, 0xe6, 0x9f, 0x0d, 0xb4, 0xa3, 0x48, 0xc0, 0xd7,
	0x59, 0x9b, 0xe0, 0x21, 0x13, 0x05, 0xd8, 0xed, 0x54, 0x7e, 0xa0, 0xe8, 0x07, 0xee, 0xf5, 0xaa,
	0xef, 0x8e, 0xe2, 0x7b, 0x5e, 0xe0, 0x4f, 0xc9, 0x12, 0x76, 0x57, 0x5d, 0xea, 0x81, 0x8c, 0xce,
	0x07, 0x81, 0x41, 0xbc, 0x0a, 0xb3, 0x11, 0x10, 0xd9, 0x5d, 0x15, 0x85, 0xf2, 0x20, 0xff, 0xc5,
	0x31, 0x48, 0xde, 0x37, 0x0d, 0x2f, 0x89, 0xbf, 0xc1, 0x41, 0xa2, 0x60, 0x61, 0x92, 0x10, 0xd1,
	0xef, 0x59, 0xfc, 0x54, 0x90, 0xc4, 0xde, 0x3e, 0xc4, 0xc3, 0x8e, 0x74, 0x97, 0xbf, 0xc6, 0xa4,
	0x05, 0x45, 0x78, 0xcb, 0x34, 0xfa, 0x71, 0x2e, 0x31, 0x9c, 0x73, 0xc0, 0xdf, 0x0f, 0x11, 0x05,
	0x95, 0x0a, 0xb2, 0xa8, 0x27, 0xc5, 0x44, 0x8e, 0xbe, 0xad, 0x91, 0x80, 0xbf, 0xd7, 0xdb, 0x58,
	0x43, 0x30, 0x45, 0xa5, 0xe7, 0xa7, 0x28, 0x2a, 0xaf, 0x1b, 0x47, 0xa1, 0xda, 0x88, 0x40, 0xd5,
	0x9f, 0x8b, 0x14, 0x95, 0xb7, 0x87, 0xde, 0x0d, 0xee, 0x21, 0x3e, 0x12, 0x5e, 0xf4, 0xf6, 0xf9,
	0x44, 0x47, 0x7a, 0x99, 0x5f, 0xea, 0xdf, 0x3e, 0x61, 0x98, 0x36, 0x29, 0x52, 0x79, 0x56, 0xa4,
	0xe8, 0x8a, 0x01, 0x68, 0xc9, 0xbc, 0xcf, 0x61, 0x5f, 0x7f, 0xe2, 0x07, 0x08, 0x3f, 0x52, 0x82,
	0xe8, 0x0e, 0x2f, 0x04, 0x36, 0xc7, 0x20, 0x38, 0x73, 0x2c, 0x98, 0xd3, 0x70, 0x25, 0xec, 0x36,
	0xb6, 0x25, 0xc6, 0x91, 0x0b, 0x0a, 0x7d, 0xd5, 0xdd, 0x0d, 0x03, 0x13, 0x87, 0x8f, 0x8e, 0xaa,
	0x28, 0x77, 0xa4, 0x97, 0xc8, 0x25, 0xd7, 0x3b, 0xc1, 0x0d, 0x88, 0xdf, 0x35, 0x06, 0x64, 0x0a,
	0x50, 0x18, 0x88, 0xb7, 0x35, 0x7b, 0x71, 0x43, 0xef, 0x70, 0xe4, 0xe8, 0xac, 0x63, 0x07, 0x47,
	0xe0, 0x89, 0x0a, 0xd5, 0x1b, 0x34, 0x95, 0x98, 0xe8, 0x53, 0xa4, 0x52, 0x9d, 0x0a, 0xb2, 0x78,
	0xa5, 0x56, 0xfc, 0x90, 0xf2, 0x7f, 0x8c, 0x41, 0xc6, 0x77, 0x3d, 0x60, 0x7f, 0xb8, 0x76, 0xf7,
	0xe4, 0x07, 0x1c, 0xc4, 0x2b, 0xe1, 0x97, 0x9a, 0xc0, 0x9f, 0xb3, 0x91, 0x98, 0x1b, 0xa4, 0x88,
	0x3c, 0xc3, 0x36, 0x65, 0xae, 0xed, 0x75, 0x16, 0xff, 0xe3, 0x56, 0x8b, 0xae, 0x90, 0x65, 0xa7,
	0x86, 0x0d, 0x72, 0x6a, 0x90, 0x42, 0x54, 0xc1, 0xc6, 0xce, 0xf0, 0x07, 0x8d, 0xef, 0x9e, 0xe5,
	0x3d, 0x69, 0x98, 0x09, 0x64, 0xa7, 0xbe, 0xe2, 0x7f, 0x51, 0x1a, 0x8c, 0xb2, 0x17, 0xed, 0x30,
	0xca, 0xe8, 0x87, 0xa3, 0xfc, 0xaf, 0x62, 0x30, 0xe3, 0x15, 0xc7, 0xa0, 0x7f, 0xbf, 0x77, 0x1e,
	0xff, 0x2a, 0x1d, 0xa9, 0xc0, 0x8b, 0x21, 0xff, 0xf6, 0x2a, 0x75, 0x17, 0xf7, 0x3c, 0xf3, 0xee,
	0x0c, 0x4c, 0x95, 0xfa, 0x68, 0x9e, 0x6f, 0x23, 0x1a, 0xf5, 0x37, 0x4f, 0x6f, 0x25, 0x43, 0xfd,
	0x7a, 0xd0, 0x91, 0x6e, 0xfb, 0xf7, 0xd0, 0x20, 0x74, 0xbd, 0xb7, 0xc4, 0x7e, 0x74, 0x51, 0xad,
	0xe3, 0xee, 0x5f, 0xb8, 0x8e, 0xf4, 0x31, 0x87, 0xde, 0xe7, 0x20, 0x55, 0xdc, 0x91, 0x7a, 0xdd,
	0x5c, 0x7c, 0x19, 0xa0, 0xd2, 0x24, 0xa7, 0xb1, 0x62, 0xbd, 0x81, 0xd1, 0xac, 0x6a, 0xd6, 0x71,
	0xd6, 0x26, 0x13, 0x6b, 0xb8, 0xde, 0xc0, 0x59, 0xd5, 0x6c, 0xe6, 0xb0, 0xae, 0xf0, 0x33, 0x76,
	0xbb, 0xd5, 0x32, 0x2d, 0xe7, 0x4e, 0x90, 0xb6, 0x52, 0x22, 0x91, 0x55, 0xd4, 0x87, 0x58, 0xc8,
	0x67, 0xd7, 0x85, 0x1d, 0x4d, 0xc5, 0x86, 0x8d, 0xd1, 0xad, 0x87, 0x8e, 0xd3, 0xb2, 0x6f, 0xe7,
	0x72, 0x0d, 0xcd, 0x79, 0xd8, 0xae, 0xd1, 0x55, 0xa8, 0x20, 0x91, 0x6b, 0x62, 0x35, 0x57, 0xd3,
	0xcd, 0x5a, 0xae, 0xa9, 0xd8, 0x0e, 0xb6, 0x72, 0x3b, 0xa5, 0x42, 0xb1, 0x5c, 0x29, 0xe6, 0xe3,
	0x2f, 0x64, 0xd7, 0x57, 0xb8, 0x58, 0x3e, 0xed, 0xcb, 0x87, 0xdc, 0x9b, 0xb6, 0x69, 0xdc, 0x0e,
	0xcd, 0xdc, 0xe7, 0x23, 0x70, 0xe6, 0x5a, 0xb5, 0x5a, 0x82, 0x06, 0xfd, 0xd6, 0xbf, 0x03, 0x00,
	0x00, 0xff, 0xff, 0x91, 0x8c, 0x51, 0xd8, 0xdd, 0x23, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ApplicationDeploymentServiceClient is the client API for ApplicationDeploymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApplicationDeploymentServiceClient interface {
	DeployContainer(ctx context.Context, in *Application, opts ...grpc.CallOption) (*ApplicationID, error)
	DeployVM(ctx context.Context, in *Application, opts ...grpc.CallOption) (*ApplicationID, error)
	GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Applications, error)
	Get(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*Application, error)
	Redeploy(ctx context.Context, in *Application, opts ...grpc.CallOption) (*empty.Empty, error)
	Remove(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*empty.Empty, error)
}

type applicationDeploymentServiceClient struct {
	cc *grpc.ClientConn
}

func NewApplicationDeploymentServiceClient(cc *grpc.ClientConn) ApplicationDeploymentServiceClient {
	return &applicationDeploymentServiceClient{cc}
}

func (c *applicationDeploymentServiceClient) DeployContainer(ctx context.Context, in *Application, opts ...grpc.CallOption) (*ApplicationID, error) {
	out := new(ApplicationID)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationDeploymentService/DeployContainer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) DeployVM(ctx context.Context, in *Application, opts ...grpc.CallOption) (*ApplicationID, error) {
	out := new(ApplicationID)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationDeploymentService/DeployVM", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Applications, error) {
	out := new(Applications)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationDeploymentService/GetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) Get(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*Application, error) {
	out := new(Application)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationDeploymentService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) Redeploy(ctx context.Context, in *Application, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationDeploymentService/Redeploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) Remove(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationDeploymentService/Remove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApplicationDeploymentServiceServer is the server API for ApplicationDeploymentService service.
type ApplicationDeploymentServiceServer interface {
	DeployContainer(context.Context, *Application) (*ApplicationID, error)
	DeployVM(context.Context, *Application) (*ApplicationID, error)
	GetAll(context.Context, *empty.Empty) (*Applications, error)
	Get(context.Context, *ApplicationID) (*Application, error)
	Redeploy(context.Context, *Application) (*empty.Empty, error)
	Remove(context.Context, *ApplicationID) (*empty.Empty, error)
}

func RegisterApplicationDeploymentServiceServer(s *grpc.Server, srv ApplicationDeploymentServiceServer) {
	s.RegisterService(&_ApplicationDeploymentService_serviceDesc, srv)
}

func _ApplicationDeploymentService_DeployContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Application)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).DeployContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationDeploymentService/DeployContainer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).DeployContainer(ctx, req.(*Application))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_DeployVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Application)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).DeployVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationDeploymentService/DeployVM",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).DeployVM(ctx, req.(*Application))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationDeploymentService/GetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).GetAll(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationDeploymentService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).Get(ctx, req.(*ApplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_Redeploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Application)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).Redeploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationDeploymentService/Redeploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).Redeploy(ctx, req.(*Application))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationDeploymentService/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).Remove(ctx, req.(*ApplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApplicationDeploymentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.ApplicationDeploymentService",
	HandlerType: (*ApplicationDeploymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeployContainer",
			Handler:    _ApplicationDeploymentService_DeployContainer_Handler,
		},
		{
			MethodName: "DeployVM",
			Handler:    _ApplicationDeploymentService_DeployVM_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _ApplicationDeploymentService_GetAll_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ApplicationDeploymentService_Get_Handler,
		},
		{
			MethodName: "Redeploy",
			Handler:    _ApplicationDeploymentService_Redeploy_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _ApplicationDeploymentService_Remove_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// ApplicationLifecycleServiceClient is the client API for ApplicationLifecycleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApplicationLifecycleServiceClient interface {
	Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
}

type applicationLifecycleServiceClient struct {
	cc *grpc.ClientConn
}

func NewApplicationLifecycleServiceClient(cc *grpc.ClientConn) ApplicationLifecycleServiceClient {
	return &applicationLifecycleServiceClient{cc}
}

func (c *applicationLifecycleServiceClient) Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationLifecycleService/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationLifecycleServiceClient) Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationLifecycleService/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationLifecycleServiceClient) Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationLifecycleService/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApplicationLifecycleServiceServer is the server API for ApplicationLifecycleService service.
type ApplicationLifecycleServiceServer interface {
	Start(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Stop(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Restart(context.Context, *LifecycleCommand) (*empty.Empty, error)
}

func RegisterApplicationLifecycleServiceServer(s *grpc.Server, srv ApplicationLifecycleServiceServer) {
	s.RegisterService(&_ApplicationLifecycleService_serviceDesc, srv)
}

func _ApplicationLifecycleService_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationLifecycleServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationLifecycleService/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationLifecycleServiceServer).Start(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationLifecycleService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationLifecycleServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationLifecycleService/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationLifecycleServiceServer).Stop(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationLifecycleService_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationLifecycleServiceServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationLifecycleService/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationLifecycleServiceServer).Restart(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApplicationLifecycleService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.ApplicationLifecycleService",
	HandlerType: (*ApplicationLifecycleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _ApplicationLifecycleService_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _ApplicationLifecycleService_Stop_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _ApplicationLifecycleService_Restart_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// VNFDeploymentServiceClient is the client API for VNFDeploymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VNFDeploymentServiceClient interface {
	Deploy(ctx context.Context, in *VNF, opts ...grpc.CallOption) (*VNFID, error)
	GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VNFs, error)
	Get(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*VNF, error)
	Redeploy(ctx context.Context, in *VNF, opts ...grpc.CallOption) (*empty.Empty, error)
	Remove(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*empty.Empty, error)
}

type vNFDeploymentServiceClient struct {
	cc *grpc.ClientConn
}

func NewVNFDeploymentServiceClient(cc *grpc.ClientConn) VNFDeploymentServiceClient {
	return &vNFDeploymentServiceClient{cc}
}

func (c *vNFDeploymentServiceClient) Deploy(ctx context.Context, in *VNF, opts ...grpc.CallOption) (*VNFID, error) {
	out := new(VNFID)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFDeploymentService/Deploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFDeploymentServiceClient) GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VNFs, error) {
	out := new(VNFs)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFDeploymentService/GetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFDeploymentServiceClient) Get(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*VNF, error) {
	out := new(VNF)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFDeploymentService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFDeploymentServiceClient) Redeploy(ctx context.Context, in *VNF, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFDeploymentService/Redeploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFDeploymentServiceClient) Remove(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFDeploymentService/Remove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VNFDeploymentServiceServer is the server API for VNFDeploymentService service.
type VNFDeploymentServiceServer interface {
	Deploy(context.Context, *VNF) (*VNFID, error)
	GetAll(context.Context, *empty.Empty) (*VNFs, error)
	Get(context.Context, *VNFID) (*VNF, error)
	Redeploy(context.Context, *VNF) (*empty.Empty, error)
	Remove(context.Context, *VNFID) (*empty.Empty, error)
}

func RegisterVNFDeploymentServiceServer(s *grpc.Server, srv VNFDeploymentServiceServer) {
	s.RegisterService(&_VNFDeploymentService_serviceDesc, srv)
}

func _VNFDeploymentService_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNF)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFDeploymentService/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).Deploy(ctx, req.(*VNF))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFDeploymentService_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFDeploymentService/GetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).GetAll(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFDeploymentService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNFID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFDeploymentService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).Get(ctx, req.(*VNFID))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFDeploymentService_Redeploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNF)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).Redeploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFDeploymentService/Redeploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).Redeploy(ctx, req.(*VNF))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFDeploymentService_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNFID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFDeploymentService/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).Remove(ctx, req.(*VNFID))
	}
	return interceptor(ctx, in, info, handler)
}

var _VNFDeploymentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.VNFDeploymentService",
	HandlerType: (*VNFDeploymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deploy",
			Handler:    _VNFDeploymentService_Deploy_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _VNFDeploymentService_GetAll_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _VNFDeploymentService_Get_Handler,
		},
		{
			MethodName: "Redeploy",
			Handler:    _VNFDeploymentService_Redeploy_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _VNFDeploymentService_Remove_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// VNFLifecycleServiceClient is the client API for VNFLifecycleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VNFLifecycleServiceClient interface {
	Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
}

type vNFLifecycleServiceClient struct {
	cc *grpc.ClientConn
}

func NewVNFLifecycleServiceClient(cc *grpc.ClientConn) VNFLifecycleServiceClient {
	return &vNFLifecycleServiceClient{cc}
}

func (c *vNFLifecycleServiceClient) Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFLifecycleService/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFLifecycleServiceClient) Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFLifecycleService/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFLifecycleServiceClient) Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFLifecycleService/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VNFLifecycleServiceServer is the server API for VNFLifecycleService service.
type VNFLifecycleServiceServer interface {
	Start(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Stop(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Restart(context.Context, *LifecycleCommand) (*empty.Empty, error)
}

func RegisterVNFLifecycleServiceServer(s *grpc.Server, srv VNFLifecycleServiceServer) {
	s.RegisterService(&_VNFLifecycleService_serviceDesc, srv)
}

func _VNFLifecycleService_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFLifecycleServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFLifecycleService/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFLifecycleServiceServer).Start(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFLifecycleService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFLifecycleServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFLifecycleService/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFLifecycleServiceServer).Stop(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFLifecycleService_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFLifecycleServiceServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFLifecycleService/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFLifecycleServiceServer).Restart(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

var _VNFLifecycleService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.VNFLifecycleService",
	HandlerType: (*VNFLifecycleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _VNFLifecycleService_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _VNFLifecycleService_Stop_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _VNFLifecycleService_Restart_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// InterfaceServiceClient is the client API for InterfaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InterfaceServiceClient interface {
	Update(ctx context.Context, in *NetworkInterface, opts ...grpc.CallOption) (*empty.Empty, error)
	BulkUpdate(ctx context.Context, in *NetworkInterfaces, opts ...grpc.CallOption) (*empty.Empty, error)
	GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NetworkInterfaces, error)
	Get(ctx context.Context, in *InterfaceID, opts ...grpc.CallOption) (*NetworkInterface, error)
}

type interfaceServiceClient struct {
	cc *grpc.ClientConn
}

func NewInterfaceServiceClient(cc *grpc.ClientConn) InterfaceServiceClient {
	return &interfaceServiceClient{cc}
}

func (c *interfaceServiceClient) Update(ctx context.Context, in *NetworkInterface, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.InterfaceService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceServiceClient) BulkUpdate(ctx context.Context, in *NetworkInterfaces, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.InterfaceService/BulkUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceServiceClient) GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NetworkInterfaces, error) {
	out := new(NetworkInterfaces)
	err := c.cc.Invoke(ctx, "/openness.ela.InterfaceService/GetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceServiceClient) Get(ctx context.Context, in *InterfaceID, opts ...grpc.CallOption) (*NetworkInterface, error) {
	out := new(NetworkInterface)
	err := c.cc.Invoke(ctx, "/openness.ela.InterfaceService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterfaceServiceServer is the server API for InterfaceService service.
type InterfaceServiceServer interface {
	Update(context.Context, *NetworkInterface) (*empty.Empty, error)
	BulkUpdate(context.Context, *NetworkInterfaces) (*empty.Empty, error)
	GetAll(context.Context, *empty.Empty) (*NetworkInterfaces, error)
	Get(context.Context, *InterfaceID) (*NetworkInterface, error)
}

func RegisterInterfaceServiceServer(s *grpc.Server, srv InterfaceServiceServer) {
	s.RegisterService(&_InterfaceService_serviceDesc, srv)
}

func _InterfaceService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkInterface)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.InterfaceService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).Update(ctx, req.(*NetworkInterface))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceService_BulkUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkInterfaces)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).BulkUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.InterfaceService/BulkUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).BulkUpdate(ctx, req.(*NetworkInterfaces))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceService_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.InterfaceService/GetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).GetAll(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.InterfaceService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).Get(ctx, req.(*InterfaceID))
	}
	return interceptor(ctx, in, info, handler)
}

var _InterfaceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.InterfaceService",
	HandlerType: (*InterfaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Update",
			Handler:    _InterfaceService_Update_Handler,
		},
		{
			MethodName: "BulkUpdate",
			Handler:    _InterfaceService_BulkUpdate_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _InterfaceService_GetAll_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InterfaceService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// ZoneServiceClient is the client API for ZoneService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ZoneServiceClient interface {
	Create(ctx context.Context, in *NetworkZone, opts ...grpc.CallOption) (*ZoneID, error)
	Update(ctx context.Context, in *NetworkZone, opts ...grpc.CallOption) (*empty.Empty, error)
	BulkUpdate(ctx context.Context, in *NetworkZones, opts ...grpc.CallOption) (*empty.Empty, error)
	GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NetworkZones, error)
	Get(ctx context.Context, in *ZoneID, opts ...grpc.CallOption) (*NetworkZone, error)
	Delete(ctx context.Context, in *ZoneID, opts ...grpc.CallOption) (*empty.Empty, error)
}

type zoneServiceClient struct {
	cc *grpc.ClientConn
}

func NewZoneServiceClient(cc *grpc.ClientConn) ZoneServiceClient {
	return &zoneServiceClient{cc}
}

func (c *zoneServiceClient) Create(ctx context.Context, in *NetworkZone, opts ...grpc.CallOption) (*ZoneID, error) {
	out := new(ZoneID)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) Update(ctx context.Context, in *NetworkZone, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) BulkUpdate(ctx context.Context, in *NetworkZones, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/BulkUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NetworkZones, error) {
	out := new(NetworkZones)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/GetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) Get(ctx context.Context, in *ZoneID, opts ...grpc.CallOption) (*NetworkZone, error) {
	out := new(NetworkZone)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) Delete(ctx context.Context, in *ZoneID, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZoneServiceServer is the server API for ZoneService service.
type ZoneServiceServer interface {
	Create(context.Context, *NetworkZone) (*ZoneID, error)
	Update(context.Context, *NetworkZone) (*empty.Empty, error)
	BulkUpdate(context.Context, *NetworkZones) (*empty.Empty, error)
	GetAll(context.Context, *empty.Empty) (*NetworkZones, error)
	Get(context.Context, *ZoneID) (*NetworkZone, error)
	Delete(context.Context, *ZoneID) (*empty.Empty, error)
}

func RegisterZoneServiceServer(s *grpc.Server, srv ZoneServiceServer) {
	s.RegisterService(&_ZoneService_serviceDesc, srv)
}

func _ZoneService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkZone)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).Create(ctx, req.(*NetworkZone))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkZone)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).Update(ctx, req.(*NetworkZone))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_BulkUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkZones)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).BulkUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/BulkUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).BulkUpdate(ctx, req.(*NetworkZones))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/GetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).GetAll(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZoneID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).Get(ctx, req.(*ZoneID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZoneID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).Delete(ctx, req.(*ZoneID))
	}
	return interceptor(ctx, in, info, handler)
}

var _ZoneService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.ZoneService",
	HandlerType: (*ZoneServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ZoneService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ZoneService_Update_Handler,
		},
		{
			MethodName: "BulkUpdate",
			Handler:    _ZoneService_BulkUpdate_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _ZoneService_GetAll_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ZoneService_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ZoneService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// ApplicationPolicyServiceClient is the client API for ApplicationPolicyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApplicationPolicyServiceClient interface {
	Set(ctx context.Context, in *TrafficPolicy, opts ...grpc.CallOption) (*empty.Empty, error)
	Get(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*TrafficPolicy, error)
}

type applicationPolicyServiceClient struct {
	cc *grpc.ClientConn
}

func NewApplicationPolicyServiceClient(cc *grpc.ClientConn) ApplicationPolicyServiceClient {
	return &applicationPolicyServiceClient{cc}
}

func (c *applicationPolicyServiceClient) Set(ctx context.Context, in *TrafficPolicy, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationPolicyService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationPolicyServiceClient) Get(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*TrafficPolicy, error) {
	out := new(TrafficPolicy)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationPolicyService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApplicationPolicyServiceServer is the server API for ApplicationPolicyService service.
type ApplicationPolicyServiceServer interface {
	Set(context.Context, *TrafficPolicy) (*empty.Empty, error)
	Get(context.Context, *ApplicationID) (*TrafficPolicy, error)
}

func RegisterApplicationPolicyServiceServer(s *grpc.Server, srv ApplicationPolicyServiceServer) {
	s.RegisterService(&_ApplicationPolicyService_serviceDesc, srv)
}

func _ApplicationPolicyService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationPolicyServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationPolicyService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationPolicyServiceServer).Set(ctx, req.(*TrafficPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationPolicyService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationPolicyServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationPolicyService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationPolicyServiceServer).Get(ctx, req.(*ApplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApplicationPolicyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.ApplicationPolicyService",
	HandlerType: (*ApplicationPolicyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _ApplicationPolicyService_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ApplicationPolicyService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// InterfacePolicyServiceClient is the client API for InterfacePolicyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InterfacePolicyServiceClient interface {
	Set(ctx context.Context, in *TrafficPolicy, opts ...grpc.CallOption) (*empty.Empty, error)
	Get(ctx context.Context, in *InterfaceID, opts ...grpc.CallOption) (*TrafficPolicy, error)
}

type interfacePolicyServiceClient struct {
	cc *grpc.ClientConn
}

func NewInterfacePolicyServiceClient(cc *grpc.ClientConn) InterfacePolicyServiceClient {
	return &interfacePolicyServiceClient{cc}
}

func (c *interfacePolicyServiceClient) Set(ctx context.Context, in *TrafficPolicy, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.InterfacePolicyService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfacePolicyServiceClient) Get(ctx context.Context, in *InterfaceID, opts ...grpc.CallOption) (*TrafficPolicy, error) {
	out := new(TrafficPolicy)
	err := c.cc.Invoke(ctx, "/openness.ela.InterfacePolicyService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterfacePolicyServiceServer is the server API for InterfacePolicyService service.
type InterfacePolicyServiceServer interface {
	Set(context.Context, *TrafficPolicy) (*empty.Empty, error)
	Get(context.Context, *InterfaceID) (*TrafficPolicy, error)
}

func RegisterInterfacePolicyServiceServer(s *grpc.Server, srv InterfacePolicyServiceServer) {
	s.RegisterService(&_InterfacePolicyService_serviceDesc, srv)
}

func _InterfacePolicyService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfacePolicyServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.InterfacePolicyService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfacePolicyServiceServer).Set(ctx, req.(*TrafficPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfacePolicyService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfacePolicyServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.InterfacePolicyService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfacePolicyServiceServer).Get(ctx, req.(*InterfaceID))
	}
	return interceptor(ctx, in, info, handler)
}

var _InterfacePolicyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.InterfacePolicyService",
	HandlerType: (*InterfacePolicyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _InterfacePolicyService_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InterfacePolicyService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}
